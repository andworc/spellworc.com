---
import type { Props } from "@astrojs/starlight/props";
import { AstroError } from "astro/errors";
import StarlightSidebar from "@astrojs/starlight/components/Sidebar.astro";
import { Badge } from "@astrojs/starlight/components";
// import BlogSidebar from "@components/sidebar/BlogSidebar.astro";
import config from "stead.config";
import { getSidebarBlogEntries } from "@libs/content";
import {
  getBlogPathWithBase,
  getSidebarProps,
  isBlogRoot,
  isBlogTagsPage,
} from "@libs/page";
import { getAllTags } from "@libs/tags";

export type SidebarData = {
  isCurrentSidebar: boolean;
  starlightProps: Props;
  labelEntry: Props["sidebar"][number];
};

const multiSidebarData: Array<SidebarData> = { ...Astro.props }.sidebar.map(
  (entry) => {
    if (entry.type !== "group") {
      throw new AstroError(
        `\`${entry.label}\` cannot be used with multi-sidebar.

  Each top-level \`sidebar\` item in the Starlight config must be either a group or autogenerated.

  See https://starlight.astro.build/guides/sidebar/#groups and https://starlight.astro.build/guides/sidebar/#autogenerated-groups for more details.`,
      );
    }

    // Recursively check if a group of sidebar entries contains the current page
    const findIfIsCurrent = (
      entry: (typeof Astro.props.sidebar)[number],
    ): boolean => {
      if (entry.type === "link") {
        return entry.isCurrent;
      }
      return entry.entries.some((item) => findIfIsCurrent(item));
    };

    const isCurrentPage = findIfIsCurrent(entry);
    return {
      isCurrentSidebar: isCurrentPage,
      starlightProps: { ...Astro.props, sidebar: [...entry.entries] },
      labelEntry: entry,
    };
  },
);

// If the current page being built is not on a sidebar then set the first sidebar to be shown
if (
  multiSidebarData[0] &&
  !multiSidebarData.some(({ isCurrentSidebar }) => isCurrentSidebar)
) {
  multiSidebarData[0].isCurrentSidebar = true;
}

let count = 0;

const sidebars = multiSidebarData.map((sidebar) => {
  const id = count++;
  return {
    panelId: "sidebar-panel-" + id,
    tabId: "sidebar-tab-" + id,
    ...sidebar,
  };
});

// ================= BLOG

const { featured, recent } = await getSidebarBlogEntries();
const blogSidebar: Props["sidebar"] = [
  {
    attrs: {},
    badge: undefined,
    href: getBlogPathWithBase("/"),
    isCurrent: isBlogRoot(Astro.props.slug),
    label: "All posts",
    type: "link",
  },
];

if (featured.length > 0) {
  blogSidebar.push({
    badge: undefined,
    collapsed: false,
    entries: getSidebarProps(Astro.props.slug, featured),
    label: "Featured posts",
    type: "group",
  });
}

blogSidebar.push({
  badge: undefined,
  collapsed: false,
  entries: getSidebarProps(Astro.props.slug, recent),
  label: "Recent posts",
  type: "group",
});

const blogTags = await getAllTags();

if (blogTags.size > 0) {
  blogSidebar.push({
    badge: undefined,
    collapsed: false,
    entries: [...blogTags]
      .sort(([, a], [, b]) => {
        if (a.entries.length === b.entries.length) {
          return a.label.localeCompare(b.label);
        }

        return b.entries.length - a.entries.length;
      })
      .map(([slug, { entries, label }]) => ({
        attrs: {},
        badge: undefined,
        href: getBlogPathWithBase(`/tags/${slug}`),
        isCurrent: isBlogTagsPage(Astro.props.slug, slug),
        label: `${label} (${entries.length})`,
        type: "link",
      })),
    label: "Tags",
    type: "group",
  });
}

if (config.astro.site) {
  blogSidebar.push({
    attrs: {},
    badge: undefined,
    href: getBlogPathWithBase("/rss.xml", true),
    isCurrent: false,
    label: "RSS",
    type: "link",
  });
}
---

<starlight-multi-sidebar-tabs>
  <div class="tablist-wrapper not-content">
    <ul role="tablist">
      {
        sidebars.map(({ labelEntry, isCurrentSidebar, panelId, tabId }) => (
          <li role="presentation" class="tab">
            {labelEntry.type === "link" && (
              <a
                role="tab"
                href={"#" + panelId}
                id={tabId}
                aria-selected={isCurrentSidebar ? "true" : "false"}
                tabindex={isCurrentSidebar ? 0 : -1}
                {...labelEntry.attrs}
              >
                <span>{labelEntry.label}</span>
                {labelEntry.badge && <Badge {...labelEntry.badge} />}
              </a>
            )}
            {labelEntry.type !== "link" && (
              <a
                role="tab"
                href={"#" + panelId}
                id={tabId}
                aria-selected={isCurrentSidebar ? "true" : "false"}
                tabindex={isCurrentSidebar ? 0 : -1}
              >
                <span>{labelEntry.label}</span>
                {labelEntry.badge && <Badge {...labelEntry.badge} />}
              </a>
            )}
          </li>
        ))
      }
    </ul>
  </div>
  {
    sidebars.map(
      ({ isCurrentSidebar, tabId, panelId, labelEntry, starlightProps }) => (
        <section
          class="__collapse-content"
          id={panelId}
          aria-labelledby={tabId}
          role="tabpanel"
          hidden={!isCurrentSidebar}
        >
          {labelEntry.label === config.blog.title ? (
            <StarlightSidebar {...Astro.props} sidebar={blogSidebar} />
          ) : (
            <StarlightSidebar {...starlightProps} />
          )}
        </section>
      ),
    )
  }
</starlight-multi-sidebar-tabs>

<style>
  starlight-tabs {
    display: block;
  }

  .tablist-wrapper {
    overflow-x: auto;
  }

  [role="tablist"] {
    display: grid;
    grid-auto-flow: column;
    grid-auto-columns: 1fr;
    justify-content: space-around;
    list-style: none;
    padding-inline: 0.5rem;
    padding-block-end: var(--sl-nav-pad-y);
  }

  .tab > [role="tab"] {
    display: block;
    text-align: center;
    font-size: var(--sl-text-base);
    font-weight: 400;
    text-decoration: none;
    color: var(--sl-color-gray-2);
    border-bottom: 1px solid var(--sl-color-gray-5);
    padding-inline: 0.2rem;
  }

  .tab > [role="tab"][aria-selected="true"] {
    @apply rounded-full border font-semibold;
    border-color: var(--sl-color-text-accent);
    color: var(--sl-color-white);
  }

  .tab > [role="tab"] > *:not(:last-child) {
    margin-inline-end: 0.25em;
  }
</style>

<script>
  class StarlighMultiSidebarTabs extends HTMLElement {
    // A map of sync keys to all tabs that are synced to that key.

    tabs: HTMLAnchorElement[];
    panels: HTMLElement[];

    constructor() {
      super();
      const tablist = this.querySelector<HTMLUListElement>('[role="tablist"]')!;
      this.tabs = [
        ...tablist.querySelectorAll<HTMLAnchorElement>('[role="tab"]'),
      ];
      this.panels = [
        ...this.querySelectorAll<HTMLElement>(':scope > [role="tabpanel"]'),
      ];

      this.tabs.forEach((tab, i) => {
        // Handle clicks for mouse users
        tab.addEventListener("click", (e) => {
          e.preventDefault();
          const currentTab = tablist.querySelector('[aria-selected="true"]');
          if (e.currentTarget !== currentTab) {
            this.switchTab(e.currentTarget as HTMLAnchorElement, i);
          }
        });

        // Handle keyboard input
        tab.addEventListener("keydown", (e) => {
          const index = this.tabs.indexOf(e.currentTarget as any);
          // Work out which key the user is pressing and
          // Calculate the new tab's index where appropriate
          const nextIndex =
            e.key === "ArrowLeft"
              ? index - 1
              : e.key === "ArrowRight"
                ? index + 1
                : e.key === "Home"
                  ? 0
                  : e.key === "End"
                    ? this.tabs.length - 1
                    : null;
          if (nextIndex === null) return;
          if (this.tabs[nextIndex]) {
            e.preventDefault();
            this.switchTab(this.tabs[nextIndex], nextIndex);
          }
        });
      });
    }

    switchTab(newTab: HTMLAnchorElement | null | undefined, index: number) {
      if (!newTab) return;

      // Mark all tabs as unselected and hide all tab panels.
      this.tabs.forEach((tab) => {
        tab.setAttribute("aria-selected", "false");
        tab.setAttribute("tabindex", "-1");
      });
      this.panels.forEach((oldPanel) => {
        oldPanel.hidden = true;
      });

      // Show new panel and mark new tab as selected.
      const newPanel = this.panels[index];
      if (newPanel) newPanel.hidden = false;
      // Restore active tab to the default tab order.
      newTab.removeAttribute("tabindex");
      newTab.setAttribute("aria-selected", "true");
    }
  }

  customElements.define(
    "starlight-multi-sidebar-tabs",
    StarlighMultiSidebarTabs,
  );
</script>
